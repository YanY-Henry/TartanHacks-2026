<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Aloha Blocks</title>
  <style>
    :root{
      --cell: 11px;
      --gap: 1px;
      --bg: #000;

      --wall:   #334155;
      --frame:  #7f1d1d;

      --goal:   #e5e7eb;
      --exit:   #22c55e;

      --p1:     #ec4899;
      --p2:     #3b82f6;

      --box:    #facc15;
      --player: #a855f7;

      --text:  #d1d5db;
      --muted: #6b7280;

      --btn:#111;
      --btnBorder:#222;
    }
    html, body {
      min-height: 100%;
    }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Noto Sans CJK SC", Arial;
      touch-action: pan-y;
      overflow-x: hidden;
    }
    .wrap{
      width: 100%;
      max-width: 520px;
      padding: 10px;
      margin: 0 auto;
      box-sizing: border-box;
    }
    .title{ font-size: 18px; margin: 0 0 8px 0; user-select:none; }
    .sub{ font-size: 14px; color: var(--muted); margin: 0 0 10px 0; user-select:none; }

    .board{ display:flex; justify-content:center; align-items:center; }
    .grid{ display:grid; gap: var(--gap); background:#000; touch-action:none; }
    .cell{ width: var(--cell); height: var(--cell); background: transparent; }

    .wall{ background: var(--wall); }
    .frame{ background: var(--frame); }
    .goal{ background: var(--goal); }
    .exit{ background: var(--exit); }
    .box{ background: var(--box); }
    .player{ background: var(--player); }

    .p1{ background: var(--p1); }
    .p2{ background: var(--p2); }

    .controls{
      margin-top: 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .hintline{ font-size: 14px; color: var(--muted); user-select:none; white-space: nowrap; }
    .btn{
      width: 56px; height: 56px;
      background: var(--btn);
      border: 1px solid var(--btnBorder);
      color: var(--text);
      border-radius: 14px;
      font-size: 18px;
      font-weight: 700;
      user-select:none;
      -webkit-user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .dpad{
      display:grid;
      grid-template-columns: repeat(3, 56px);
      grid-template-rows: repeat(3, 56px);
      gap: 8px;
    }

    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(2px);
    }
    .overlay.show{ display:flex; }
    .done{
      color: #34d399;
      font-size: 18px;
      font-weight: 800;
      letter-spacing: .5px;
      user-select:none;
    }

    .hintline.done{
      color:#34d399;
      font-weight:700;
    }

    @media (max-width: 420px){
      :root{ --cell: 16px; }
      .btn{ width: 52px; height: 52px; border-radius: 14px; }
      .dpad{ grid-template-columns: repeat(3, 52px); grid-template-rows: repeat(3, 52px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <p class="title">Aloha Blocks (F=Frame, G=Box Goal, E=Exit)</p>
    <p class="sub">Move with Arrow Keys / on-screen buttons. U = Undo, R = Reset. Boxes lock into walls when pushed onto G.</p>

    <div class="board">
      <div class="grid" id="grid"></div>
    </div>

    <div class="controls">
      <div class="hintline" id="status">Push boxes onto G, then step on E</div>

      <div class="dpad" aria-label="Direction pad">
        <div></div>
        <button class="btn" data-dir="up">‚Üë</button>
        <div></div>
        <button class="btn" data-dir="left">‚Üê</button>
        <button class="btn" data-dir="down">‚Üì</button>
        <button class="btn" data-dir="right">‚Üí</button>
        <div></div><div></div><div></div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="done">Completed</div>
  </div>

<script>
(() => {
  const LEVEL = [
    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
    "F#G#####.#....#.#...#..#######F",
    "F#B...BG.#..##.#....#..#.....#F",
    "F#.###.#.##..#..###.##.#.###.#F",
    "F#.##1.#.###.##.#..##..1.###.#F",
    "F#.#2#.#..##.##.#..#.#.#.###.#F",
    "FGB....#.###...B...G#..#.....#F",
    "F#######.#.#.#.#.#.#.#.#######F",
    "F..........##....###.G..B...P.F",
    "F##..###...#.#.#..#.##..#.####F",
    "F..####..#.....##......#.#####F",
    "F.####.##.##..###..B.#.......#F",
    "F#.#..#.#.#..#.##.#..#.####.##F",
    "F#..##.#.#..#.###.#..##.#...#.F",
    "F..#.......#.#.##......G######F",
    "F####..#.B.G#####.##..#.####.#F",
    "F###....#####.#..##.####.#..##F",
    "F#.....#.....##..##..##.....#.F",
    "F#.###...###..####.#.#.####.##F",
    "F....#.#....B...G.#..#.#...#.#F",
    "F..###...###.#.#.###...##...##F",
    "F##.###.#.###.###.#..######..#F",
    "F........#.#.#..####.#...#...#F",
    "F#G###G#...######..###.#.###.#F",
    "F#B...B#.##.#.#..##.##...#....F",
    "F#.###.#.#.#.G#.....#######.#.F",
    "F#.##E.#.....B#######.#......#F",
    "F#.###.#..#.....#.#...#...####F",
    "FGB....2.##..#.####.##....#.##F",
    "F#######.#..#.##..#..#.#....#.F",
    "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
  ];

  let W = LEVEL[0].length, H = LEVEL.length;

  let walls = new Set();
  let frames = new Set();
  let goals = new Set();
  let exit = null;
  let portals = new Map();

  let boxes = new Set();
  let locked = new Set();
  let player = {x:0, y:0};

  let history = [];
  let finished = false;

  const gridEl = document.getElementById("grid");
  const statusEl = document.getElementById("status");
  const overlayEl = document.getElementById("overlay");

  const key = (x,y) => `${x},${y}`;
  const isDigit = (c) => c >= "0" && c <= "9";

  function parseLevel(){
    walls.clear(); frames.clear(); goals.clear(); boxes.clear(); locked.clear();
    portals = new Map();
    history = [];
    finished = false;
    overlayEl.classList.remove("show");

    for (let y=0; y<H; y++){
      for (let x=0; x<W; x++){
        const c = LEVEL[y][x];
        const k = key(x,y);
        if (c === "#") walls.add(k);
        else if (c === "F") frames.add(k);
        else if (c === "G") goals.add(k);
        else if (c === "B") boxes.add(k);
        else if (c === "P") player = {x,y};
        else if (c === "E") exit = {x,y};
        else if (isDigit(c) && c !== "0") {
          if (!portals.has(c)) portals.set(c, []);
          portals.get(c).push(k);
        }
      }
    }
  }

  function pushHistory(){
    history.push({
      player: {x: player.x, y: player.y},
      boxes: new Set(boxes),
      goals: new Set(goals),
      locked: new Set(locked),
      finished
    });
  }

  function undo(){
    if (finished) return;
    const prev = history.pop();
    if (!prev) return;
    player = prev.player;
    boxes = prev.boxes;
    goals = prev.goals;
    locked = prev.locked;
    finished = prev.finished;
    render();
  }

  function reset(){
    parseLevel();
    render();
  }

  function isBlockedKey(k){
    return walls.has(k) || frames.has(k) || locked.has(k);
  }

  function isBlocked(x,y){
    return isBlockedKey(key(x,y));
  }

  function hasBox(x,y){
    return boxes.has(key(x,y));
  }

  function allGoalsDone(){
    return goals.size === 0;
  }

  function checkWin(){
    if (!exit) return false;
    if (!allGoalsDone()) return false;
    return player.x === exit.x && player.y === exit.y;
  }

  function finish(){
    finished = true;
    statusEl.textContent = "üéâ Completed! All goals locked.";
    statusEl.classList.add("done");
  }

  function portalDest(fromX, fromY){
    const c = LEVEL[fromY][fromX];
    if (!isDigit(c) || c === "0") return null;
    const ends = portals.get(c);
    if (!ends || ends.length !== 2) return null;
    const here = key(fromX, fromY);
    const other = (ends[0] === here) ? ends[1] : ends[0];
    return other;
  }

  function tryTeleportEntity(toX, toY){
    const destKey = portalDest(toX, toY);
    if (!destKey) return { ok:true, x:toX, y:toY };

    const [dx, dy] = destKey.split(",").map(Number);
    if (isBlocked(dx,dy)) return { ok:false };
    if (boxes.has(destKey)) return { ok:false };

    return { ok:true, x:dx, y:dy, teleported:true };
  }

  function tryMove(dx,dy){
    if (finished) return;

    const nx = player.x + dx, ny = player.y + dy;
    if (isBlocked(nx,ny)) return;

    if (hasBox(nx,ny)){
      const bx1 = nx + dx, by1 = ny + dy;
      if (isBlocked(bx1,by1) || hasBox(bx1,by1)) return;

      pushHistory();

      const fromK = key(nx,ny);
      boxes.delete(fromK);

      let moved = tryTeleportEntity(bx1, by1);
      if (!moved.ok){
        boxes.add(fromK);
        history.pop();
        return;
      }

      const finalBoxK = key(moved.x, moved.y);
      boxes.add(finalBoxK);

      player = {x:nx, y:ny};

      if (goals.has(finalBoxK)){
        goals.delete(finalBoxK);
        boxes.delete(finalBoxK);
        locked.add(finalBoxK);
      }

      const pMoved = tryTeleportEntity(player.x, player.y);
      if (pMoved.ok && pMoved.teleported){
        player = {x:pMoved.x, y:pMoved.y};
      }

      render();
      if (checkWin()) finish();
      return;
    }

    pushHistory();
    let pm = tryTeleportEntity(nx, ny);
    if (!pm.ok) {
      history.pop();
      return;
    }
    player = {x: pm.x, y: pm.y};
    render();
    if (checkWin()) finish();
  }

  function render(){
    gridEl.style.gridTemplateColumns = `repeat(${W}, var(--cell))`;
    gridEl.style.gridTemplateRows = `repeat(${H}, var(--cell))`;
    gridEl.innerHTML = "";

    for (let y=0; y<H; y++){
      for (let x=0; x<W; x++){
        const el = document.createElement("div");
        el.className = "cell";
        const k = key(x,y);
        const c = LEVEL[y][x];

        if (locked.has(k)) el.classList.add("wall");
        else if (walls.has(k)) el.classList.add("wall");
        else if (frames.has(k)) el.classList.add("frame");
        else if (boxes.has(k)) el.classList.add("box");
        else if (player.x===x && player.y===y) el.classList.add("player");
        else if (goals.has(k)) el.classList.add("goal");
        else if (exit && exit.x===x && exit.y===y) el.classList.add("exit");
        else if (isDigit(c) && c !== "0") el.classList.add(c === "1" ? "p1" : c === "2" ? "p2" : "p1");

        gridEl.appendChild(el);
      }
    }

    if (finished) statusEl.textContent = "Completed!";
    else if (!allGoalsDone()) statusEl.textContent = `Push boxes onto G (remaining: ${goals.size})`;
    else statusEl.textContent = "All G locked. Step on E to finish.";
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","w"].includes(k)) { e.preventDefault(); tryMove(0,-1); }
    else if (["arrowdown","s"].includes(k)) { e.preventDefault(); tryMove(0,1); }
    else if (["arrowleft","a"].includes(k)) { e.preventDefault(); tryMove(-1,0); }
    else if (["arrowright","d"].includes(k)) { e.preventDefault(); tryMove(1,0); }
    else if (k === "u") { e.preventDefault(); undo(); }
    else if (k === "r") { e.preventDefault(); reset(); }
  }, {passive:false});

  document.querySelectorAll("[data-dir]").forEach(btn => {
    const dir = btn.getAttribute("data-dir");
    const map = { up:[0,-1], down:[0,1], left:[-1,0], right:[1,0] };
    const [dx,dy] = map[dir];
    btn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); tryMove(dx,dy); });
  });

  overlayEl.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    overlayEl.classList.remove("show");
  });
  overlayEl.addEventListener("dblclick", reset);

  parseLevel();
  render();
})();
</script>
</body>
</html>
